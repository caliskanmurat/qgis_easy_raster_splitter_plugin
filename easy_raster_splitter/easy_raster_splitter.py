# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ClipRaster
                                 A QGIS plugin
 This plugin allows you to split raster files based on given polygon data.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-12-13
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Murat ÇALIŞKAN
        email                : caliskan.murat.20@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.utils import iface

from qgis.core import Qgis, QgsProject

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .easy_raster_splitter_dialog import ClipRasterDialog
import os.path

import numpy as np
from osgeo import gdal, ogr
import os


class ClipRaster:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ClipRaster_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Easy Raster Splitter')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ClipRaster', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToRasterMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/easy_raster_splitter/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Easy Raster Splitter'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginRasterMenu(
                self.tr(u'&Easy Raster Splitter'),
                action)
            self.iface.removeToolBarIcon(action)

    def selectOutput(self):
        self.dlg.lineEdit_outRaster.setText("")
        self.OutputDir = QFileDialog.getExistingDirectory(None, 'Open working directory', "", QFileDialog.ShowDirsOnly)
        self.dlg.lineEdit_outRaster.setText(self.OutputDir)
        self.dlg.button_box.setEnabled(True)
    
    def convertCoors(self, raster, coors, pix_size, pix2real=True):
        self.trans = gdal.Transformer(raster, None, [])
        if pix2real:
            #pixel to real --> trans.TransformPoint(0, col=1078, row=648)
            self.col, self.row = coors
            self.success, (self.x, self.y, self.z) = self.trans.TransformPoint(0, self.col, self.row)
            return self.x + pix_size/2, self.y-pix_size/2
        else:
            #real to pixel --> trans.TransformPoint(1, x=405460.0, y=4198500.0)
            self.x, self.y = coors        
            self.success, self.crz = self.trans.TransformPoint(1, self.x, self.y)
            self.c, self.r, self.z = map(int, self.crz)
            return self.c, self.r

    def writeRaster(self, out_file, cols, rows, srs, geot, arrays, dtype, nodata):
        self.driver = gdal.GetDriverByName('GTiff')
        self.out_ds = self.driver.Create(out_file, cols, rows, len(arrays), dtype)
        self.out_ds.SetGeoTransform(geot)
        self.out_ds.SetProjection(srs)
        for e,array in enumerate(arrays, 1):            
            self.out_band = self.out_ds.GetRasterBand(e)
            self.out_band.SetNoDataValue(nodata)
            self.out_band.WriteArray(array)
        del self.out_ds, self.out_band
                
    def getLayers(self):
        self.dlg.comboBox_in_vector.clear()
        self.dlg.comboBox_in_raster.clear()
        
        self.dlg.comboBox_in_vector.addItems(self.vector_layers.keys())
        self.dlg.comboBox_in_raster.addItems(self.raster_layers.keys())
        
    def fillFields(self):
        self.dlg.comboBox_names.clear()
        self.selectedLayer = self.vector_layers[self.dlg.comboBox_in_vector.currentText()]
        self.fields = ["fid"] + [field.name() for field in self.selectedLayer.fields() if (field.typeName().lower()=='string') or (field.typeName().lower().startswith("int"))]
        self.dlg.comboBox_names.addItems(self.fields)        
        
    def toggleCheckBox(self, name):
        if name == "full":
            if self.dlg.checkBox_full.isChecked():
                self.dlg.lineEdit_name.setEnabled(True)
                self.dlg.lineEdit_name.setText("")
            else:
                self.dlg.lineEdit_name.setEnabled(False)
                self.dlg.lineEdit_name.setText("")
                
        elif name == "feature":
            if self.dlg.checkBox_feature.isChecked():
                self.dlg.comboBox_names.setEnabled(True)
                self.fillFields()
            else:
                self.dlg.comboBox_names.setEnabled(False)
                self.dlg.comboBox_names.clear()

    def getResults(self, layer, raster, out_folder, geot, arrays, nodata, outputNameFeatureField, outputNameFull, erased=False, split_features=False, split_full=True):
        self.res_arrays = [np.full_like(array, nodata) for array in arrays]
        self.res_arrays_reversed = [array for array in arrays]
        
        self.srs = raster.GetProjection()
    
        self.mp = ogr.Geometry(ogr.wkbMultiPolygon)
        for feat in layer.getFeatures():
            self.geomWkt = feat.geometry().buffer(0,5).asWkt()
            self.geom = ogr.CreateGeometryFromWkt(self.geomWkt)
                
            self.points_all = []
            if self.geom.GetGeometryName() == "MULTIPOLYGON":
                for g in self.geom:
                    self.mp.AddGeometry(g)
            else:
                self.mp.AddGeometry(self.geom)
                
            self.minX, self.maxX, self.minY, self.maxY = self.geom.GetEnvelope()
            self.col_left, self.row_top = self.convertCoors(raster, (self.minX, self.maxY), pix_size=geot[1], pix2real=False)
            self.col_right, self.row_bottom = self.convertCoors(raster, (self.maxX, self.minY), pix_size=geot[1], pix2real=False)
            if self.geom.GetGeometryCount() == 1:
                self.ring = self.geom.GetGeometryRef(0).Clone()
                self.points = [self.convertCoors(raster, i, pix_size=geot[1], pix2real=False) for i in self.ring.GetPoints()]
                self.points = np.array(self.points)
                self.points_all.append(self.points)
            else:
                for part in self.geom:
                    if part.GetGeometryCount() == 0:
                        self.ring = part.Clone()
                        self.points = [self.convertCoors(raster, i, pix_size=geot[1], pix2real=False) for i in self.ring.GetPoints()]
                        self.points = np.array(self.points)
                        self.points_all.append(self.points)
                    else:
                        for subpart in part:
                            self.ring = subpart.Clone()
                            self.points = [self.convertCoors(raster, i, pix_size=geot[1], pix2real=False) for i in self.ring.GetPoints()]
                            self.points = np.array(self.points)
                            self.points_all.append(self.points)
        
            self.array_erased_list = [array.copy() for array in arrays]
            self.foo = [cv2.fillPoly(array_erased, np.array(self.points_all), float(nodata)) for array, array_erased in zip(arrays, self.array_erased_list)]
            
            if erased:
                self.new_arrays_reversed = [np.where(array_erased==nodata, nodata, array) for array, array_erased in zip(arrays, self.array_erased_list)]
                self.res_arrays_reversed = [np.where(new_array_reversed==nodata, nodata, res_array_reversed) for new_array_reversed, res_array_reversed in zip(self.new_arrays_reversed, self.res_arrays_reversed)]
                self.res_arrays = self.res_arrays_reversed
                self.new_arrays = self.new_arrays_reversed
            
            else:
                 self.new_arrays = [np.where(array_erased==nodata, array, nodata) for array, array_erased in zip(arrays, self.array_erased_list)]
                 self.res_arrays = [np.where(new_array!=nodata, new_array, res_array) for new_array, res_array in zip(self.new_arrays, self.res_arrays)]
                              
            if split_features:
                if outputNameFeatureField == "fid":
                    self.name = feat.id()
                else:
                    self.name = feat.attribute(outputNameFeatureField)
                
                self.row_top_offset = 5 if self.row_top > 5 else 0
                self.col_left_offset = 5 if self.col_left > 5 else 0
                self.row_bottom_offset, self.col_right_offset = (5,5)
                
                self.new_array_clipped_list = [new_array[self.row_top-self.row_top_offset:self.row_bottom+self.row_bottom_offset,
                            self.col_left-self.col_left_offset:self.col_right+self.col_right_offset] for new_array in self.new_arrays]
                
                self.out_file = os.path.join(out_folder, "{}.tif".format(str(self.name).strip()))
                self.rows, self.cols = self.new_array_clipped_list[0].shape
                self.geot_new = list(geot)
                self.geot_new[0] += ((self.col_left-self.col_left_offset) * geot[1])
                self.geot_new[3] += ((self.row_top-self.row_top_offset) * geot[5])
                self.geot_new = tuple(self.geot_new)
                
                try:
                    self.writeRaster(self.out_file, self.cols, self.rows, self.srs, self.geot_new, self.new_array_clipped_list, self.dtype, nodata)
                except:
                    print(self.name,"couldn't created.")
                
                if self.dlg.checkBox_add.isChecked():
                    iface.addRasterLayer(self.out_file, str(self.name))
        
        if split_full:
            if not outputNameFull:
                outputNameFull = "outRaster_full"
                
            self.minX_tum, self.maxX_tum, self.minY_tum, self.maxY_tum = self.mp.GetEnvelope()
            self.col_left_tum, self.row_top_tum = self.convertCoors(raster, (self.minX_tum, self.maxY_tum), pix_size=geot[1], pix2real=False)
            self.col_right_tum, self.row_bottom_tum = self.convertCoors(raster, (self.maxX_tum, self.minY_tum), pix_size=geot[1], pix2real=False)
            
            self.row_top_offset_tum = 5 if self.row_top_tum > 5 else 0
            self.col_left_offset_tum = 5 if self.col_left_tum > 5 else 0
            self.row_bottom_offset_tum, self.col_right_offset_tum = (5,5)
            
            self.out_file = os.path.join(out_folder, outputNameFull + ".tif")
            
            if not erased:            
                self.new_res_arrays = [res_array[self.row_top_tum - self.row_top_offset_tum : self.row_bottom_tum + self.row_bottom_offset_tum,
                                self.col_left_tum-self.col_left_offset_tum:self.col_right_tum+self.col_right_offset_tum] for res_array in self.res_arrays]
                                
                self.rows_tum, self.cols_tum = self.new_res_arrays[0].shape
                
                self.geot_new_tum = list(geot)
                self.geot_new_tum[0] += ((self.col_left_tum - self.col_left_offset_tum) * geot[1])
                self.geot_new_tum[3] += ((self.row_top_tum - self.row_top_offset_tum) * geot[5])
                self.geot_new_tum = tuple(self.geot_new_tum)
                self.writeRaster(self.out_file, self.cols_tum, self.rows_tum, self.srs, self.geot_new_tum, self.new_res_arrays, self.dtype, nodata)
                
                if self.dlg.checkBox_add.isChecked():
                    iface.addRasterLayer(self.out_file, outputNameFull)
            
            else:
                self.rows_tum, self.cols_tum = self.res_arrays[0].shape
                self.writeRaster(self.out_file, self.cols_tum, self.rows_tum, self.srs, geot, self.res_arrays, self.dtype, nodata)
                
                if self.dlg.checkBox_add.isChecked():
                    iface.addRasterLayer(self.out_file, outputNameFull)
            
           
    def run(self):
        """Run method that performs all the real work"""
        try:
            import cv2
        except:
            self.iface.messageBar().pushMessage("Error", "opencv couldn't be impported successfully! Please check the GitHub page to learn how to install manually." , level=Qgis.Critical, duration=10)
           
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.dlg = ClipRasterDialog()
            self.vector_layers = {layer.name():layer for layer in QgsProject.instance().mapLayers().values() if (layer.type()== 0 and layer.wkbType() in (3,6))}
            self.raster_layers = {layer.name():layer for layer in QgsProject.instance().mapLayers().values() if layer.type()== 1}
            self.getLayers()
            
            self.dlg.checkBox_full.toggled.connect(lambda x:self.toggleCheckBox("full"))
            self.dlg.checkBox_feature.toggled.connect(lambda x:self.toggleCheckBox("feature"))
            self.dlg.comboBox_in_vector.currentTextChanged.connect(self.fillFields)
            self.dlg.toolButton_selectOutFolder.clicked.connect(self.selectOutput)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            
            self.rasterName = self.dlg.comboBox_in_raster.currentText()
            self.vectorName = self.dlg.comboBox_in_vector.currentText()
            
            self.raster_path = self.raster_layers[self.rasterName].source()
            self.vector_layer = self.vector_layers[self.vectorName]
            
            self.raster = gdal.Open(self.raster_path)
            self.geot = self.raster.GetGeoTransform()
            self.bands = [self.raster.GetRasterBand(band_no) for band_no in range(1, self.raster.RasterCount+1)]
            self.dtype = self.bands[0].DataType
            self.arrays = [band.ReadAsArray() for band in self.bands]
            self.nodata = self.bands[0].GetNoDataValue()
            
            if not self.nodata:
                try:
                    self.nanofbands = [np.iinfo(array.dtype).min for array in self.arrays]
                    self.nodata = min(self.nanofbands)
                except:
                    self.nanofbands = [np.finfo(array.dtype).min for array in self.arrays]
                    self.nodata = min(self.nanofbands)
            
            self.out_folder = self.dlg.lineEdit_outRaster.text()
            self.erased = False if self.dlg.radioButton_clip.isChecked() else True
            self.split_features = True if self.dlg.checkBox_feature.isChecked() else False
            self.split_full = True if self.dlg.checkBox_full.isChecked() else False
            self.outputNameFeatureField = self.dlg.comboBox_names.currentText()
            self.outputNameFull = self.dlg.lineEdit_name.text()            
            
            if self.out_folder:
                try:
                    self.getResults(self.vector_layer, self.raster, self.out_folder, self.geot, self.arrays, self.nodata, self.outputNameFeatureField, self.outputNameFull, self.erased, self.split_features, self.split_full)
                    self.iface.messageBar().pushMessage("Success", "Raster was clipped/erased successfully!" , level=Qgis.Success, duration=5)
                except:
                    pass
       
            
            
